break down training samples, 250-char max

Which training samples are over 250 chars?
[x] 8.  251  2
[x] 21. 1651 7
[x] 20. 721  3
[x] 4.  1703 7
[x] 17. 3460 14
[x] 2.  534  3
[x] 19. 5469 22
[x] 16. 1584 7
[x] 18. 318  2
[x] 12. 1025 5
[x] 6.  973  4
[x] 22. 989  4
[x] 1.  623  3
[x] 13. 260  2
[x] 14. 2549 11
[x] 15. 454  2
[x] 9.  1159 5
[x] 11. 1079 5
[x] 5.  880  4
[x] 10. 2195 10
[ ] 3.  1195 5
[ ] 7.  1244 5


split progress:
#!/usr/local/bin/python3

# For training data, we'll be using an hour-long interview that the
# assemblymember gave on the Max Politics podcast. It's available on
# soundcloud at 
# https://soundcloud.com/gotham-gazette-max-murphy/assemblymember-alex-bores-on-ai-opportunity-court-reform-housing-policy-more.

from pydub import AudioSegment

input_file = (
    "Assemblymember Alex Bores on AI Opportunity, "
    + "Court Reform, Housing Policy, & More.mp3"
)

# convert take the mp3 from soundcloud...
sound = AudioSegment.from_mp3(input_file)

for timeRange_ms in enumerate(
    [ # timestamps for slices are in milliseconds -- I got them
      # by listening to the podcast and noting when Alex starts
      # and stops talking.
      # (start time, stop time), with time as (min*60 + sec) * 1000
      ((4  * 60 + 22) * 1000, (4  * 60 + 28) * 1000), # 00 (original)
      ((5  * 60 + 11) * 1000, (5  * 60 + 45) * 1000), # 01 (original)
      ((6  * 60 + 14) * 1000, (6  * 60 + 45) * 1000), # 02 (original)
      ((7  * 60 +  9) * 1000, (8  * 60 + 14) * 1000), # 03 (original)

      ((10 * 60 + 13) * 1000, (10 * 60 + 22) * 1000), # 04 (modified 1/10)
      ((10 * 60 + 22) * 1000, (10 * 60 + 37) * 1000), # 04 (original 2/10)
      ((10 * 60 + 37) * 1000, (10 * 60 + 45) * 1000), # 04 (original 3/10)
      ((10 * 60 + 45) * 1000, (10 * 60 + 55.5) * 1000), # 04 (original 4/10)
      ((10 * 60 + 55.5) * 1000, (10 * 60 + 59.5) * 1000), # 04 (original 5/10)
      ((10 * 60 + 59.5) * 1000, (11 * 60 + 10) * 1000), # 04 (original 6/10)
      ((11 * 60 + 10) * 1000, (11 * 60 + 16.5) * 1000), # 04 (original 7/10)
      ((11 * 60 + 16.5) * 1000, (11 * 60 + 29) * 1000), # 04 (original 8/10)
      ((11 * 60 + 29) * 1000, (11 * 60 + 35) * 1000), # 04 (original 9/10)
      ((11 * 60 + 35) * 1000, (11 * 60 + 46) * 1000), # 04 (original 10/10)

      ((12 * 60 + 23) * 1000, (13 * 60 +  6) * 1000), # 05 (original)
      ((15 * 60 +  9) * 1000, (16 * 60 +  6) * 1000), # 06 (original)

      ((18 * 60 +  7) * 1000, (18 * 60 + 12) * 1000), # 07 (modified 1/2)
      ((18 * 60 + 12) * 1000, (19 * 60 + 21) * 1000), # 07 (modified 2/2)

      ((19 * 60 + 25) * 1000, (19 * 60 + 40) * 1000), # 08 (original)
      ((20 * 60 + 17) * 1000, (21 * 60 + 23) * 1000), # 09 (original)
      ((21 * 60 + 53) * 1000, (23 * 60 + 58) * 1000), # 10 (original)
      ((24 * 60 + 27) * 1000, (25 * 60 + 25) * 1000), # 11 (original)
      ((25 * 60 + 51) * 1000, (26 * 60 + 45) * 1000), # 12 (original)
      ((27 * 60 + 12) * 1000, (27 * 60 + 25) * 1000), # 13 (original)
      ((29 * 60 + 42) * 1000, (32 * 60 + 18) * 1000), # 14 (original)
      ((32 * 60 + 57) * 1000, (33 * 60 + 22) * 1000), # 15 (original)
      ((33 * 60 + 51) * 1000, (35 * 60 + 24) * 1000), # 16 (original)

      ((36 * 60 + 27) * 1000, (36 * 60 + 34.5) * 1000), # 17 (original)
      ((36 * 60 + 34.5) * 1000, (36 * 60 + 42) * 1000), # 17 (original)
      ((36 * 60 + 42) * 1000, (36 * 60 + 50.5) * 1000), # 17 (original)
      ((36 * 60 + 50.5) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)
      ((36 * 60 + 27) * 1000, (39 * 60 + 52) * 1000), # 17 (original)


      ((39 * 60 + 57) * 1000, (40 * 60 + 14) * 1000), # 18 (original)
      ((41 * 60 + 59) * 1000, (47 * 60 + 13) * 1000), # 19 (original)

      ((48 * 60 +  4) * 1000, (48 * 60 + 15) * 1000), # 20 (modified 1/4)
      ((48 * 60 + 15) * 1000, (48 * 60 + 26) * 1000), # 20 (modified 2/4)
      ((48 * 60 + 26) * 1000, (48 * 60 + 39.5) * 1000), # 20 (modified 3/4)
      ((48 * 60 + 39.5) * 1000, (48 * 60 + 44) * 1000), # 20 (modified 4/4)

      ((50 * 60 + 13) * 1000, (50 * 60 + 21) * 1000), # 21 (modified 1/9)
      ((50 * 60 + 21) * 1000, (50 * 60 + 28.5) * 1000), # 21 (modified 2/9)
      ((50 * 60 + 28.5) * 1000, (50 * 60 + 37) * 1000), # 21 (modified 3/9)
      ((50 * 60 + 37) * 1000, (50 * 60 + 51) * 1000), # 21 (modified 4/9)
      ((50 * 60 + 51) * 1000, (51 * 60 + 5.5) * 1000), # 21 (modified 5/9)
      ((51 * 60 + 5.5) * 1000, (51 * 60 + 21.5) * 1000), # 21 (modified 6/9)
      ((51 * 60 + 21.5) * 1000, (51 * 60 + 34) * 1000), # 21 (modified 7/9)
      ((51 * 60 + 34) * 1000, (51 * 60 + 39.5) * 1000), # 21 (modified 8/9)
      ((50 * 60 + 39.5) * 1000, (51 * 60 + 50) * 1000), # 21 (modified 9/9)

      ((52 * 60 + 20) * 1000, (53 * 60 + 44) * 1000), # 22 (original)
      ]
    ):
    sound[timeRange_ms[1][0] : timeRange_ms[1][1]].export(
        "AlexBoresVoice" + str(timeRange_ms[0]) + ".wav", format="wav"
        )